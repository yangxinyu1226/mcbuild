# AI 我的世界建造大师 (v3.0 智能架构版)

## 项目核心理念

本项目旨在实现两大核心目标：
1.  **完成复杂建造**：通过AI的规划、设计与执行能力，完成传统脚本难以实现的复杂、宏大、富有创意的建筑项目。
2.  **实现自我进化**：构建一个能够根据未知需求，自我扩展能力、自动编写新工具的软件系统，使其具备理论上无限的成长潜力。

---

## 两大独立的执行系统

本项目包含两套功能独立、用法不同的系统，以适应不同的使用场景。

#### 1. 独立装饰设计器 (Designer System)

-   **定位**：轻量、快速、手动。
-   **用途**：用于快速生成和建造小型、独立的装饰性建筑，如喷泉、雕像、路灯等。
-   **特点**：拥有图形界面（GUI），操作直观，即用即建，非常适合新手或快速验证创意。

##### Designer 系统文件结构

这套轻量系统主要由以下几个文件构成：

-   `designer/`
    -   `gui.py`: **图形用户界面 (GUI)**。运行此文件会弹出一个窗口，让你通过输入文字来生成装饰品，是这套系统的主要入口。
    -   `decoration_generator.py`: **装饰品生成器**。`gui.py` 的后端，负责与大模型（LLM）通信，根据你的描述生成装饰品的JSON蓝图。
    -   `listener.py`: **游戏内指令监听器**。一个需要独立在后台运行的服务，它会连接到你的服务器并监听游戏聊天，以执行 `list` 和 `add` 指令。
    -   `我的世界清单名称.txt`: **物品名词库**。一个补充性的文本文件，包含了大量的Minecraft物品和方块名称，用于在生成模型时提示大模型，提高它设计的准确性和多样性。
-   `box/`
    -   这是一个**输出目录**，所有由 `gui.py` 生成的装饰品JSON蓝图都会被保存在这里，等待 `listener.py` 的调用。

#### 2. 主规划系统 (Main Planner System)

-   **定位**：强大、复杂、自动化。
-   **用途**：用于建造大型、多部件、结构复杂的宏伟建筑，如城堡、村庄、复杂地形等。
-   **特点**：全自动化，拥有“思考”、“决策”和“自我进化”的能力，是本项目的核心与精华所在。

---

## 主规划系统全流程深度解析

当你输入 `!build` 指令后，主规划系统会启动一套精密的、环环相扣的工作流程。以下是其详细步骤。

### 第一步：指令解析与总指挥 (`main_planner.py`)

`main_planner`是整个系统的总指挥。当它从任务队列中读取到你的指令后，它的第一个核心任务是进行**决策**。

-   **决策点一：我是否需要一个新工具？**
    1.  **扫描工具箱**：总指挥首先会扫描 `generators/` 文件夹，获取一份当前所有可用“工具”（生成器脚本）的清单。
    2.  **AI路由决策**：它将你的建筑描述和这份工具清单，一同发送给一个作为“路由器”的大语言模型（LLM），并提问：“要完成这个任务，我应该使用清单里的哪个或哪些工具？还是说我需要一个全新的工具？”
    3.  **执行或进化**：
        -   **如果AI认为现有工具足够**，它会告诉总指挥应该使用哪些生成器。流程进入下一步。
        -   **如果AI认为需要新工具**（比如你要求建一个“海盗船”，而没有对应的生成器），它会指示总指挥调用 `generator_designer.py`（生成器设计师）。设计师会**自动编写一个全新的 `pirate_ship_generator.py` 脚本**并存入工具箱。然后，最初的指令会被重新执行，在这一次，总指挥就能找到并使用这个新工具了。这就是系统的“自我进化”能力。

### 第二步：组件生成与生成器原理

在确定了需要使用的生成器后，总指挥会调用它们去分头执行任务。这些生成器自身也应用了不同的原理。

-   **标准生成器 (Standard Generator)**
    -   **原理**：接受一个相对简单的任务描述（如“一个木屋”），通过一次AI调用，将描述转换成一个由`cube`, `sphere`等基础几何图元构成的JSON建筑蓝图。
    -   **代表**: `building_generator.py`

-   **智能生成器 (Smart Generator)**
    -   **原理**：采用“分而治之”的策略来处理大型、重复性的任务（如一面长城）。
    -   **决策点二：我是否需要将任务分段？**
        1.  **AI参数提取**：它会先通过一次快速的AI调用，将你的模糊描述（“一堵很长的墙”）解析成精确参数（`{"length": 100, "height": 10}`）。
        2.  **逻辑判断**：通过一个简单的 `if length > 20` 判断，决定任务规模是否需要分段。
        3.  **分段或单次执行**：如果任务过大，它会进入一个循环，重复调用AI生成标准长度的“墙段”，最后在内部将所有墙段拼接成一个完整的、巨大的建筑蓝图。如果任务不大，则直接一次性生成。
    -   **代表**: `long_wall_generator.py`

### 第三步：智能布局与位置计算 (`supervisor.py`)

所有生成器完成工作后，会在 `build/` 目录留下一堆独立的建筑组件蓝图。此时，“建筑结构总工程师”——`supervisor.py`登场，它的核心任务是**计算每个组件的精确位置**。

-   **决策点三：这些组件应该如何摆放？**
    1.  **信息汇总**：监理师会读取所有组件的蓝图，并提取每个组件的尺寸信息（`dimensions` 和 `bounding_box`）。
    2.  **AI空间规划**：它将所有组件的信息列表发送给一个作为“结构工程师”的大语言模型，并提出一个复杂的3D布局问题：“请为这些组件安排一个合理、美观且**绝不重叠**的3D空间偏移量（offset）。”
    3.  **输出布局方案**：AI会返回一个包含每个组件精确 `x, y, z` 偏移量的最终布局方案 `final_build_plan.json`。它被教导要遵循“地基在下，屋顶在上”等建筑学基本逻辑，并利用边界框数据进行精确计算，从而解决了组件的错位和重叠问题。

### 第四步：最终施工 (`execute_final_plan` 函数)

这是将虚拟蓝图变为现实世界建筑的最后一步，由 `main_planner.py` 中的 `execute_final_plan` 函数负责。

1.  **读取最终方案**: 函数首先读取由监理师（Supervisor）生成的 `final_build_plan.json` 文件，获取每个建筑组件（如 `roof.json`, `walls.json`）的精确空间偏移量（offset）。

2.  **获取玩家基准坐标**: 它会通过RCON获取指令发出玩家的实时游戏坐标，这个坐标将作为整个宏伟建筑的**绝对基准点** (`base_x`, `base_y`, `base_z`)。

3.  **坐标换算**: 这是最关键的计算环节。函数会遍历所有组件，并对组件中的每一个方块，应用一个三级相加的坐标换算公式，将其局部坐标变为最终的世界坐标：

    `最终世界坐标 = 玩家基准坐标 + 组件偏移坐标 + 方块相对坐标`

    -   **玩家基准坐标**: 整个建筑的落地点。
    -   **组件偏移坐标**: 由监理师AI计算得出，决定了房顶相对于墙壁的位置。
    -   **方块相对坐标**: 在单个组件蓝图内部，决定了方块相对于该组件原点的位置。

4.  **执行建造**: 所有方块的绝对坐标计算完毕后，会被汇总到一个最终的施工清单中。最后，RCON客户端会连接到服务器，将清单中的成千上万条 `/setblock` 指令逐一执行，完成建造。

---

## 使用指南

#### Designer 系统 (快速、手动)

1.  **生成模型**: 运行 `python designer/gui.py`，在图形界面中输入描述，生成模型到 `box` 文件夹。
2.  **启动服务**: 打开**新**终端，运行 `python designer/listener.py`，并使其保持运行。
3.  **游戏内建造**: 在游戏聊天框输入 `list` 查看模型列表，输入 `add <编号>` 进行建造。

#### Main Planner 系统 (复杂、自动)

1.  **启动服务**: **同时打开两个**独立的终端窗口，分别运行：
    -   `python -X utf8 src/main_planner.py`
    -   `python -X utf8 src/mc_listener.py`
2.  **游戏内建造**: 在游戏聊天框输入 `!build <你的复杂建筑描述>`。

## 配置

-   `config/api_keys.json`: 配置你的 `deepseek_api_key`。
-   `config/rcon_settings.json`: 配置服务器地址、RCON密码和**服务器日志文件的绝对路径**。

---

## 附录：搭建本地Spigot服务器 (可选)

本项目需要连接一个《我的世界》服务器来执行建造。如果你没有服务器，可以按照以下步骤在本地快速搭建一个Spigot（水龙头）服务器。

1.  **下载 BuildTools**:
    -   从 [SpigotMC 官网](https://www.spigotmc.org/wiki/buildtools/) 下载 `BuildTools.jar`。
    -   你需要同时安装 [Java](https://www.java.com/en/download/) 和 [Git](https://git-scm.com/downloads/)。

2.  **编译服务器核心文件**:
    -   将下载的 `BuildTools.jar` 放在一个空文件夹里。
    -   在此文件夹内，右键打开 Git Bash 终端，运行以下命令（`1.19.4` 可替换为你想要的游戏版本）:
        ```bash
        java -jar BuildTools.jar --rev 1.19.4
        ```
    -   等待编译完成，这会花费几分钟。完成后，文件夹内会出现 `spigot-1.19.4.jar` (版本号可能不同) 这样的文件。

3.  **创建并配置服务器**:
    -   新建一个文件夹，作为你的服务器根目录（例如 `MyServer`）。
    -   将上一步生成的 `spigot-*.jar` 文件移动到这个新文件夹里。
    -   在服务器根目录里，创建一个启动脚本。
        -   **Windows**: 新建一个文本文档，粘贴以下内容，然后将其重命名为 `start.bat`。
            ```batch
            @echo off
            java -Xms1G -Xmx2G -jar spigot-1.19.4.jar nogui
            pause
            ```
            *(请确保 `-jar` 后面的文件名与你的spigot核心文件名完全一致)*

4.  **同意EULA协议**:
    -   双击运行 `start.bat`。它会报错并退出，但会生成一些新文件。
    -   打开新生成的 `eula.txt` 文件，将 `eula=false` 改为 `eula=true`，然后保存。

5.  **启用 RCON (关键步骤)**:
    -   用文本编辑器打开 `server.properties` 文件。
    -   找到并修改以下三行：
        ```properties
        enable-rcon=true
        rcon.port=25575
        rcon.password=your_strong_password_here
        ```
    -   请务必设置一个**你自己的密码**。这个密码需要和本项目 `config/rcon_settings.json` 文件中的 `rcon_password` 完全一致。

6.  **启动服务器**:
    -   再次运行 `start.bat`。这次服务器应该就能成功启动了。
    -   启动后，你还需要在 `config/rcon_settings.json` 文件中，将 `log_file_path` 指向你服务器目录下的 `logs/latest.log` 文件。
